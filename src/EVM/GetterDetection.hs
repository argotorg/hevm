-- | Static analysis for detecting storage-copy loops generated by the Solidity
-- compiler for @public bytes@ and @public string@ getter functions.
--
-- Solidity auto-generates getter functions for public state variables.
-- For dynamic types (@bytes@, @string@), the generated bytecode contains a
-- backward-JUMPI loop that reads consecutive storage slots into memory.
-- In symbolic execution this loop appears unbounded, causing @MaxIterationsReached@
-- even though it terminates deterministically given the storage state.
--
-- This module detects such loops statically so the symbolic executor can
-- short-circuit them.
module EVM.GetterDetection
  ( detectStorageCopyLoops
  ) where

import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Set (Set)
import Data.Set qualified as Set
import Data.Vector qualified as V

import EVM.Types (Op, GenericOp(..), StorageCopyLoop(..))
import EVM.Expr (maybeLitWordSimp)

-- | Scan a contract's already-parsed op vector for storage-copy loops.
--
-- A storage-copy loop is a bytecode region satisfying:
--
--   * A @JUMPDEST@ at position @p@ (loop head)
--   * A @JUMP@ or @JUMPI@ at position @q > p@ whose statically known target is exactly @p@
--     (backward jump, detected via the immediately preceding @PUSH <target>@ instruction)
--   * The body @[p, q]@ contains at least one @SLOAD@ and at least one @MSTORE@/@MSTORE8@
--   * The body contains no side-effect opcodes (@SSTORE@, @TSTORE@, @LOG*@, @CALL*@,
--     @CREATE*@, @SELFDESTRUCT@)
--   * All inner @JUMP@/@JUMPI@ targets (with a statically known push) stay within @[p, q]@
--
-- Returns a map from loop-head PC to loop descriptor.
detectStorageCopyLoops :: V.Vector (Int, Op) -> Map Int StorageCopyLoop
detectStorageCopyLoops ops =
  let jumpdests  = buildJumpdestSet ops
      candidates = findBackwardJumps ops jumpdests
      loops      = [loop | (p, q) <- candidates, Just loop <- [analyseBody ops p q]]
  in Map.fromList [(l.loopHeadPC, l) | l <- loops]

-- ---------------------------------------------------------------------------
-- Internal helpers
-- ---------------------------------------------------------------------------

-- | Collect all byte-PCs that have a JUMPDEST.
buildJumpdestSet :: V.Vector (Int, Op) -> Set Int
buildJumpdestSet ops =
  V.foldr (\(pc, op) acc -> case op of
              OpJumpdest -> Set.insert pc acc
              _          -> acc)
          Set.empty ops

-- | Find all (target, jumpPC) pairs where the instruction at @jumpPC@ is a
-- @JUMP@ or @JUMPI@, the immediately preceding instruction is @PUSH <Lit target>@,
-- and @target < jumpPC@ and @target@ is a known JUMPDEST.
findBackwardJumps :: V.Vector (Int, Op) -> Set Int -> [(Int, Int)]
findBackwardJumps ops jumpdests = go 1
  where
    n = V.length ops
    go i
      | i >= n    = []
      | otherwise =
          let (q, op)     = ops V.! i
              (_, prevOp) = ops V.! (i - 1)
          in case op of
               OpJump  -> checkPrev q prevOp (go (i + 1))
               OpJumpi -> checkPrev q prevOp (go (i + 1))
               _       -> go (i + 1)

    checkPrev q prevOp acc =
      case prevOp of
        OpPush w ->
          case maybeLitWordSimp w of
            Just target ->
              let t = fromIntegral target
              in if t < q && Set.member t jumpdests
                 then (t, q) : acc
                 else acc
            Nothing -> acc
        _ -> acc

-- | Analyse the body between loop-head @p@ (inclusive) and jump-instruction
-- @q@ (inclusive).  Returns a 'StorageCopyLoop' when all structural
-- conditions are satisfied.
analyseBody :: V.Vector (Int, Op) -> Int -> Int -> Maybe StorageCopyLoop
analyseBody ops p q = do
  let body    = V.filter (\(pc, _) -> pc >= p && pc <= q) ops
  let opcodes = fmap snd body

  let hasSload      = V.any (== OpSload) opcodes
  let hasMstore     = V.any (\op -> op == OpMstore || op == OpMstore8) opcodes
  let hasSideEffect = V.any isSideEffect opcodes
  let innerJumpsOk  = checkInnerJumps body p q

  if hasSload && hasMstore && not hasSideEffect && innerJumpsOk
    then Just StorageCopyLoop
           { loopHeadPC  = p
           , loopJumpiPC = q
           , loopExitPC  = q + 1  -- JUMP/JUMPI are single-byte opcodes
           }
    else Nothing

-- | True for opcodes that have observable side effects beyond memory/stack.
isSideEffect :: Op -> Bool
isSideEffect = \case
  OpSstore       -> True
  OpTstore       -> True
  OpLog _        -> True
  OpCall         -> True
  OpCallcode     -> True
  OpDelegatecall -> True
  OpStaticcall   -> True
  OpCreate       -> True
  OpCreate2      -> True
  OpSelfdestruct -> True
  _              -> False

-- | Check that all JUMP/JUMPI instructions in the body whose target is
-- statically known stay within [p, q].
checkInnerJumps :: V.Vector (Int, Op) -> Int -> Int -> Bool
checkInnerJumps body p q = go 1
  where
    n = V.length body
    go i
      | i >= n    = True
      | otherwise =
          let (_, op)     = body V.! i
              (_, prevOp) = body V.! (i - 1)
          in case op of
               OpJump  -> checkTarget prevOp (go (i + 1))
               OpJumpi -> checkTarget prevOp (go (i + 1))
               _       -> go (i + 1)

    checkTarget prevOp cont =
      case prevOp of
        OpPush w ->
          case maybeLitWordSimp w of
            Just target ->
              let t = fromIntegral target
              in if t >= p && t <= q then cont else False
            Nothing -> cont  -- unknown target; conservatively allow
        _ -> cont  -- unknown target; conservatively allow
