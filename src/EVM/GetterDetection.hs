-- | Static analysis for detecting memory-to-memory copy loops generated by the
-- Solidity compiler (MLOAD → MSTORE), e.g. when ABI-encoding a bytes/string
-- return value. When the source buffer is abstract the entire copy can be
-- summarised as a single CopySlice (i.e. b = a).
--
-- Detected loops are short-circuited by the symbolic executor.
module EVM.GetterDetection
  ( detectStorageCopyLoops
  ) where

import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Set (Set)
import Data.Set qualified as Set
import Data.Vector qualified as V

import EVM.Types (StorageCopyLoop(..), LoopStackInfo(..))
import EVM.Expr (maybeLitWordSimp)
import EVM.Op

-- | Scan a contract's already-parsed op vector for storage-copy loops.
--
-- A storage-copy loop is a bytecode region satisfying:
--
--   * A JUMPDEST at position p (loop head)
--   * A JUMP or JUMPI at position q > p whose statically known target is exactly p
--     (backward jump, detected via the immediately preceding PUSH <target> instruction)
--   * The body [p, q] contains at least one SLOAD and at least one MSTORE/MSTORE8
--   * The body contains no side-effect opcodes (SSTORE, TSTORE, LOG*, CALL*,
--     CREATE*, SELFDESTRUCT)
--   * All inner JUMP/JUMPI targets (with a statically known push) stay within [p, q]
--
-- Returns a map from loop-head PC to loop descriptor.
detectStorageCopyLoops :: V.Vector (Int, Op) -> Map Int StorageCopyLoop
detectStorageCopyLoops ops =
  let jumpdests  = buildJumpdestSet ops
      candidates = findBackwardJumps ops jumpdests
      loops      = [loop | (p, q) <- candidates, Just loop <- [analyseBody ops p q]]
  in Map.fromList [(l.loopHeadPC, l) | l <- loops]

-- | Collect all byte-PCs that have a JUMPDEST.
buildJumpdestSet :: V.Vector (Int, Op) -> Set Int
buildJumpdestSet ops =
  V.foldr (\(pc, op) acc -> case op of
              OpJumpdest -> Set.insert pc acc
              _          -> acc)
          Set.empty ops

-- | Find all (target, jumpPC) pairs where the instruction at jumpPC is a
-- JUMP or JUMPI, the immediately preceding instruction is PUSH <Lit target>,
-- and target < jumpPC and target is a known JUMPDEST.
findBackwardJumps :: V.Vector (Int, Op) -> Set Int -> [(Int, Int)]
findBackwardJumps ops jumpdests = go 1
  where
    n = V.length ops
    go i
      | i >= n    = []
      | otherwise =
          let (q, op)     = ops V.! i
              (_, prevOp) = ops V.! (i - 1)
          in case op of
               OpJump  -> checkPrev q prevOp (go (i + 1))
               OpJumpi -> checkPrev q prevOp (go (i + 1))
               _       -> go (i + 1)

    checkPrev q prevOp acc =
      case prevOp of
        OpPush w ->
          case maybeLitWordSimp w of
            Just target ->
              let t = fromIntegral target
              in if t < q && Set.member t jumpdests
                 then (t, q) : acc
                 else acc
            Nothing -> acc
        _ -> acc

-- | Analyse the body between loop-head p (inclusive) and jump-instruction
-- q (inclusive).  Returns a 'StorageCopyLoop' when all structural
-- conditions are satisfied.
--
-- Accepts memory-to-memory loops: body contains MLOAD and MSTORE/MSTORE8 but no SLOAD.
analyseBody :: V.Vector (Int, Op) -> Int -> Int -> Maybe StorageCopyLoop
analyseBody ops p q = do
  let body    = V.filter (\(pc, _) -> pc >= p && pc <= q) ops
  let opcodes = fmap snd body

  let hasSload      = V.any (== OpSload) opcodes
  let hasMload      = V.any (== OpMload) opcodes
  let hasMstore     = V.any (\op -> op == OpMstore || op == OpMstore8) opcodes
  let hasSideEffect = V.any isSideEffect opcodes
  let jumpsOK       = noInnerJumps body p q
  let isStackNeutral = case traverse stackDelta (V.toList opcodes) of
        Just deltas -> sum deltas == 0
        Nothing     -> False

  let isMemCopy = hasMload && hasMstore && not hasSload

  if isMemCopy && not hasSideEffect && jumpsOK && isStackNeutral
    then Just StorageCopyLoop
           { loopHeadPC  = p
           , loopJumpiPC = q
           , loopExitPC  = q + 1  -- JUMP/JUMPI are single-byte opcodes
           , stackLayout = extractStackLayout ops p q
           }
    else Nothing

-- | Check that the only JUMP/JUMPI in the body is the loop-closing one at q.
-- A genuine getter loop has no internal control flow other than the single
-- backward jump that closes the loop.
noInnerJumps :: V.Vector (Int, Op) -> Int -> Int -> Bool
noInnerJumps body _ q = V.all noInnerJump body
  where
    noInnerJump (pc, op) = case op of
      OpJump  -> pc == q
      OpJumpi -> pc == q
      _       -> True

-- ---------------------------------------------------------------------------
-- Abstract stack simulation for extracting loop variable positions

-- | Abstract stack value.
-- 'Orig i' means the value that was at depth i (0 = TOS) at the loop head.
-- 'Computed' means the value was produced by some computation.
data AV = Orig Int | Computed deriving (Eq, Show)

type AbstractStack = [AV]

-- | Simulate the loop body on an abstract stack to find which original stack
-- positions hold the key variables of a memory-to-memory copy loop at the JUMPI.
--
-- The body is filtered to opcodes with PCs in [p, q].  We skip the final
-- PUSH<loopHead> + JUMP/JUMPI pair (the loop-closing instructions) because
-- we want the stack state *just before* they execute — that gives us the
-- condition and the remaining loop variables.
extractStackLayout :: V.Vector (Int, Op) -> Int -> Int -> Maybe LoopStackInfo
extractStackLayout ops p q =
  let body     = V.toList $ V.filter (\(pc, _) -> pc >= p && pc <= q) ops
      -- Drop the last two ops: PUSH<loopHead> and JUMP/JUMPI
      bodyOps  = map snd $ if length body >= 2 then init (init body) else []
      initStk  = map Orig [0..1023]  -- EVM max stack depth is 1024
  in go bodyOps initStk Nothing Nothing Nothing
  where
    -- Recurse through opcodes accumulating (mloadSrc, mstoreAddr, cmpOperands).
    go :: [Op] -> AbstractStack
       -> Maybe AV       -- ^ AV of the source offset consumed by MLOAD
       -> Maybe AV       -- ^ AV of the destination address consumed by MSTORE
       -> Maybe (AV, AV) -- ^ Two operands of the comparison opcode
       -> Maybe LoopStackInfo
    go [] _ mloadSrc mstoreA cmpOps = do
      lsAV  <- mloadSrc
      maAV  <- mstoreA
      (c1, c2) <- cmpOps
      lsDepth <- getOrig lsAV
      maDepth <- getOrig maAV
      -- The end bound is the comparison operand that is NOT the source offset
      -- (the source offset may have been incremented and appear as Computed).
      ekDepth <- case (c1, c2) of
        (Orig a, Orig b)
          | a == lsDepth -> Just b
          | b == lsDepth -> Just a
          | otherwise    -> Nothing  -- neither matches — unrecognised
        (Computed, Orig b) -> Just b
        (Orig a, Computed) -> Just a
        _ -> Nothing
      pure LoopStackInfo
        { srcOffDepth = lsDepth
        , endOffDepth = ekDepth
        , dstOffDepth = maDepth
        }
    go _ [] _ _ _ = Nothing  -- stack underflow — shouldn't happen for neutral body
    go (op:rest) stk mloadSrc mstoreA cmpOps =
      case op of
        OpJumpdest -> go rest stk mloadSrc mstoreA cmpOps

        OpPush _   -> go rest (Computed : stk) mloadSrc mstoreA cmpOps

        OpPush0    -> go rest (Computed : stk) mloadSrc mstoreA cmpOps

        OpDup n ->
          let idx = fromIntegral n - 1  -- DUP1 → index 0
          in if idx < length stk
             then go rest (stk !! idx : stk) mloadSrc mstoreA cmpOps
             else Nothing  -- stack underflow

        OpSwap n ->
          let idx = fromIntegral n  -- SWAP1 exchanges TOS with index 1
          in if idx < length stk
             then case stk of
                    (top:rest') -> case splitAt (idx - 1) rest' of
                      (before, target:after) -> go rest (target : before ++ [top] ++ after) mloadSrc mstoreA cmpOps
                      _ -> Nothing
                    _ -> Nothing
             else Nothing

        OpPop -> case stk of
          (_:rest') -> go rest rest' mloadSrc mstoreA cmpOps
          []        -> Nothing

        -- SLOAD is not tracked here; storage-to-memory loops get stackLayout=Nothing.
        OpSload -> case stk of
          (_:rest') -> go rest (Computed : rest') mloadSrc mstoreA cmpOps
          []        -> Nothing

        -- Record the source offset consumed by MLOAD.
        OpMload -> case stk of
          (addr:rest') -> go rest (Computed : rest') (Just addr) mstoreA cmpOps
          []           -> Nothing

        OpMstore -> case stk of
          (addr:_) -> go rest (drop 2 stk) mloadSrc (Just addr) cmpOps
          []       -> Nothing

        OpMstore8 -> case stk of
          (addr:_) -> go rest (drop 2 stk) mloadSrc (Just addr) cmpOps
          []       -> Nothing

        OpLt  -> recordCmp stk rest mloadSrc mstoreA cmpOps
        OpGt  -> recordCmp stk rest mloadSrc mstoreA cmpOps
        OpSlt -> recordCmp stk rest mloadSrc mstoreA cmpOps
        OpSgt -> recordCmp stk rest mloadSrc mstoreA cmpOps
        OpEq  -> recordCmp stk rest mloadSrc mstoreA cmpOps

        _ -> case stackDelta op of
               Just d ->
                 let pops = 1 - d  -- inputs = outputs - delta, assuming outputs = 1
                 in if pops > length stk
                    then Nothing  -- stack underflow
                    else go rest (Computed : drop pops stk) mloadSrc mstoreA cmpOps
               Nothing -> Nothing  -- indeterminate — bail out

    recordCmp stk rest mloadSrc mstoreA _ = case stk of
      (a:b:rest') -> go rest (Computed : rest') mloadSrc mstoreA (Just (a, b))
      _           -> Nothing

    getOrig (Orig i) = Just i
    getOrig Computed = Nothing
