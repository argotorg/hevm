-- | Static analysis for detecting storage-copy loops generated by the Solidity
-- compiler for public bytes and public string getter functions.
--
-- Solidity auto-generates getter functions for public state variables.
-- For dynamic types (bytes, string), the generated bytecode contains a
-- backward-JUMPI loop that reads consecutive storage slots into memory.
-- In symbolic execution this loop appears unbounded, causing MaxIterationsReached
-- even though it terminates deterministically given the storage state.
--
-- This module detects such loops statically so the symbolic executor can
-- short-circuit them.
module EVM.GetterDetection
  ( detectStorageCopyLoops
  ) where

import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Set (Set)
import Data.Set qualified as Set
import Data.Vector qualified as V

import EVM.Types (StorageCopyLoop(..), LoopStackInfo(..))
import EVM.Expr (maybeLitWordSimp)
import EVM.Op

-- | Scan a contract's already-parsed op vector for storage-copy loops.
--
-- A storage-copy loop is a bytecode region satisfying:
--
--   * A JUMPDEST at position p (loop head)
--   * A JUMP or JUMPI at position q > p whose statically known target is exactly p
--     (backward jump, detected via the immediately preceding PUSH <target> instruction)
--   * The body [p, q] contains at least one SLOAD and at least one MSTORE/MSTORE8
--   * The body contains no side-effect opcodes (SSTORE, TSTORE, LOG*, CALL*,
--     CREATE*, SELFDESTRUCT)
--   * All inner JUMP/JUMPI targets (with a statically known push) stay within [p, q]
--
-- Returns a map from loop-head PC to loop descriptor.
detectStorageCopyLoops :: V.Vector (Int, Op) -> Map Int StorageCopyLoop
detectStorageCopyLoops ops =
  let jumpdests  = buildJumpdestSet ops
      candidates = findBackwardJumps ops jumpdests
      loops      = [loop | (p, q) <- candidates, Just loop <- [analyseBody ops p q]]
  in Map.fromList [(l.loopHeadPC, l) | l <- loops]

-- | Collect all byte-PCs that have a JUMPDEST.
buildJumpdestSet :: V.Vector (Int, Op) -> Set Int
buildJumpdestSet ops =
  V.foldr (\(pc, op) acc -> case op of
              OpJumpdest -> Set.insert pc acc
              _          -> acc)
          Set.empty ops

-- | Find all (target, jumpPC) pairs where the instruction at jumpPC is a
-- JUMP or JUMPI, the immediately preceding instruction is PUSH <Lit target>,
-- and target < jumpPC and target is a known JUMPDEST.
findBackwardJumps :: V.Vector (Int, Op) -> Set Int -> [(Int, Int)]
findBackwardJumps ops jumpdests = go 1
  where
    n = V.length ops
    go i
      | i >= n    = []
      | otherwise =
          let (q, op)     = ops V.! i
              (_, prevOp) = ops V.! (i - 1)
          in case op of
               OpJump  -> checkPrev q prevOp (go (i + 1))
               OpJumpi -> checkPrev q prevOp (go (i + 1))
               _       -> go (i + 1)

    checkPrev q prevOp acc =
      case prevOp of
        OpPush w ->
          case maybeLitWordSimp w of
            Just target ->
              let t = fromIntegral target
              in if t < q && Set.member t jumpdests
                 then (t, q) : acc
                 else acc
            Nothing -> acc
        _ -> acc

-- | Analyse the body between loop-head p (inclusive) and jump-instruction
-- q (inclusive).  Returns a 'StorageCopyLoop' when all structural
-- conditions are satisfied.
analyseBody :: V.Vector (Int, Op) -> Int -> Int -> Maybe StorageCopyLoop
analyseBody ops p q = do
  let body    = V.filter (\(pc, _) -> pc >= p && pc <= q) ops
  let opcodes = fmap snd body

  let hasSload      = V.any (== OpSload) opcodes
  let hasMstore     = V.any (\op -> op == OpMstore || op == OpMstore8) opcodes
  let hasSideEffect = V.any isSideEffect opcodes
  let jumpsOK       = noInnerJumps body p q
  let isStackNeutral = case traverse stackDelta (V.toList opcodes) of
        Just deltas -> sum deltas == 0
        Nothing     -> False

  if hasSload && hasMstore && not hasSideEffect && jumpsOK && isStackNeutral
    then Just StorageCopyLoop
           { loopHeadPC  = p
           , loopJumpiPC = q
           , loopExitPC  = q + 1  -- JUMP/JUMPI are single-byte opcodes
           , stackLayout = extractStackLayout ops p q
           }
    else Nothing

-- | Check that the only JUMP/JUMPI in the body is the loop-closing one at q.
-- A genuine getter loop has no internal control flow other than the single
-- backward jump that closes the loop.
noInnerJumps :: V.Vector (Int, Op) -> Int -> Int -> Bool
noInnerJumps body _ q = V.all noInnerJump body
  where
    noInnerJump (pc, op) = case op of
      OpJump  -> pc == q
      OpJumpi -> pc == q
      _       -> True

-- ---------------------------------------------------------------------------
-- Abstract stack simulation for extracting loop variable positions

-- | Abstract stack value.
-- 'Orig i' means the value that was at depth i (0 = TOS) at the loop head.
-- 'Computed' means the value was produced by some computation.
data AV = Orig Int | Computed deriving (Eq, Show)

type AbstractStack = [AV]

-- | Simulate the loop body on an abstract stack to find which original stack
-- positions hold storageKey, endKey and memOffset at the JUMPI.
--
-- The body is filtered to opcodes with PCs in [p, q].  We skip the final
-- PUSH<loopHead> + JUMP/JUMPI pair (the loop-closing instructions) because
-- we want the stack state *just before* they execute — that gives us the
-- condition and the remaining loop variables.
extractStackLayout :: V.Vector (Int, Op) -> Int -> Int -> Maybe LoopStackInfo
extractStackLayout ops p q =
  let body     = V.toList $ V.filter (\(pc, _) -> pc >= p && pc <= q) ops
      -- Drop the last two ops: PUSH<loopHead> and JUMP/JUMPI
      bodyOps  = map snd $ if length body >= 2 then init (init body) else []
      initStk  = map Orig [0..1023]  -- EVM max stack depth is 1024
  in go bodyOps initStk Nothing Nothing Nothing
  where
    -- Recurse through opcodes accumulating (sloadKey, mstoreAddr, cmpOperands)
    go :: [Op] -> AbstractStack
       -> Maybe AV       -- ^ AV consumed by SLOAD (storageKey)
       -> Maybe AV       -- ^ AV of mem address consumed by MSTORE
       -> Maybe (AV, AV) -- ^ Two operands of the comparison opcode
       -> Maybe LoopStackInfo
    go [] stk sloadK mstoreA cmpOps = do
      -- After simulating the pre-condition body, TOS is the comparison result.
      -- We already captured the comparison operands in cmpOps.
      skAV  <- sloadK
      maAV  <- mstoreA
      (c1, c2) <- cmpOps
      skDepth <- getOrig skAV
      maDepth <- getOrig maAV
      -- endKey is the operand in the comparison that is NOT the storageKey
      -- (storageKey may have been incremented and appear as Computed)
      ekDepth <- case (c1, c2) of
        (Orig a, Orig b)
          | a == skDepth -> Just b
          | b == skDepth -> Just a
          | otherwise    -> Nothing  -- neither matches — unrecognised
        (Computed, Orig b) -> Just b
        (Orig a, Computed) -> Just a
        _ -> Nothing
      pure LoopStackInfo
        { storageKeyDepth = skDepth
        , endKeyDepth     = ekDepth
        , memOffDepth     = maDepth
        }
    go _ [] _ _ _ = Nothing  -- stack underflow — shouldn't happen for neutral body
    go (op:rest) stk sloadK mstoreA cmpOps =
      case op of
        OpJumpdest -> go rest stk sloadK mstoreA cmpOps

        OpPush _   -> go rest (Computed : stk) sloadK mstoreA cmpOps

        OpPush0    -> go rest (Computed : stk) sloadK mstoreA cmpOps

        OpDup n ->
          let idx = fromIntegral n - 1  -- DUP1 → index 0
          in if idx < length stk
             then go rest (stk !! idx : stk) sloadK mstoreA cmpOps
             else Nothing  -- stack underflow

        OpSwap n ->
          let idx = fromIntegral n  -- SWAP1 exchanges TOS with index 1
          in if idx < length stk
             then let (top:rest') = stk
                      (before, target:after) = splitAt (idx - 1) rest'
                  in go rest (target : before ++ [top] ++ after) sloadK mstoreA cmpOps
             else Nothing

        OpPop -> go rest (tail stk) sloadK mstoreA cmpOps

        OpSload ->
          let key = head stk
          in go rest (Computed : tail stk) (Just key) mstoreA cmpOps

        OpMstore ->
          let addr = head stk
          in go rest (drop 2 stk) sloadK (Just addr) cmpOps

        OpMstore8 ->
          let addr = head stk
          in go rest (drop 2 stk) sloadK (Just addr) cmpOps

        OpLt  -> recordCmp stk rest sloadK mstoreA cmpOps
        OpGt  -> recordCmp stk rest sloadK mstoreA cmpOps
        OpSlt -> recordCmp stk rest sloadK mstoreA cmpOps
        OpSgt -> recordCmp stk rest sloadK mstoreA cmpOps
        OpEq  -> recordCmp stk rest sloadK mstoreA cmpOps

        _ -> case stackDelta op of
               -- Assume all remaining ops produce exactly 1 output (Computed).
               -- This holds for all EVM arithmetic/logic ops.  The 0-output ops
               -- (MSTORE, MSTORE8, POP, side-effect ops) are handled above.
               Just d ->
                 let pops = 1 - d  -- inputs = outputs - delta, assuming outputs = 1
                 in if pops > length stk
                    then Nothing  -- stack underflow
                    else go rest (Computed : drop pops stk) sloadK mstoreA cmpOps
               Nothing -> Nothing  -- indeterminate — bail out

    recordCmp stk rest sloadK mstoreA _ =
      let (a:b:rest') = stk
      in go rest (Computed : rest') sloadK mstoreA (Just (a, b))

    getOrig (Orig i) = Just i
    getOrig Computed = Nothing
