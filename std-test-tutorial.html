<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Forge std-test tutorial - hevm</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hevm</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/argotorg/hevm" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="hhttps://github.com/argotorg/hevm/edit/main/src/std-test-tutorial.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="forge-std-test-usage-tutorial"><a class="header" href="#forge-std-test-usage-tutorial">Forge std-test Usage Tutorial</a></h1>
<p>First, install foundry:</p>
<pre><code class="language-plain">curl -L https://foundry.paradigm.xyz | bash
foundryup
</code></pre>
<p>Then set up a forge project with <code>forge init</code>:</p>
<pre><code class="language-plain">mkdir myproject
cd myproject
forge init --no-git .
</code></pre>
<p>Now, let's create a file <code>src/example-test.sol</code> with some simple code.
Test cases must be prepended with <code>prove_</code> and the testing contract must
inherit from <code>Test</code> from <a href="https://book.getfoundry.sh/forge/forge-std">Forge's standard test
library</a>. So let's import Test:
<code>import {Test} from "forge-std/Test.sol";</code> and then inherit from it via
<code> is Test</code>. This allows hevm to discover the test cases it needs
to run:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";
contract Example is Test {
  function prove_mytest() public {
  // (1) environment setup, preconditions
  // (2) calls to test
  // (3) postcondition checks
  }
}
</code></pre>
<p>Once you have written such a test case, you need to compile with <code>forge build --ast</code>
(see <a href="https://book.getfoundry.sh/forge/tests">forge documentation</a> for more
details) and then:</p>
<pre><code class="language-plain">$ forge build --ast
$ hevm test --match "prove_mytest"
Checking 1 function(s) in contract src/example-test.sol:Example
[RUNNING] prove_mytest(uint256)
   [PASS] prove_mytest(uint256)
</code></pre>
<p>Here, hevm discovered the test case, and automatically checked it for
violations. If <code>hevm</code> is not in the global path, you can run hevm
from wherever it is installed, and specify the root of the foundry project,
like so:</p>
<pre><code class="language-plain">./hevm test --root /path/to/foundry/project
</code></pre>
<p>The <code>--match ...</code> options is used to specify which test case(s) to run,
and it accepts a regular expression.</p>
<h2 id="setting-up-test-context"><a class="header" href="#setting-up-test-context">Setting Up Test Context</a></h2>
<p>Tests usually need to set up the environment in a particular way, such
as contract address, storage, etc. This can be done via Cheat Codes that
can change the address of the caller, set block number, etc. See <a href="#supported-cheat-codes">Cheat
Codes</a> below for a range of cheat codes supported. Cheat Codes
are a standard method used by other tools, such as
<a href="https://book.getfoundry.sh/">Foundry</a>, so you should be able to re-use your
existing setup. An example setup could be put into <code>src/setup-test.sol</code>:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";

contract MyVault {
    mapping(address =&gt; uint256) public balance;
    function deposit() external payable {
        balance[msg.sender] += msg.value;
    }
}
contract MySetupTest is Test {
    MyVault vault;
    function setUp() public {
        vault = new MyVault();

        address user1 = address(42);
        vm.deal(user1, 7 ether);
        vm.prank(user1);
        vault.deposit{value: 7 ether}();
    }

    function prove_correct(uint8 amt) public {
        address k = address(42);
        uint pre = vault.balance(k);
        assert(pre == 7 ether);
        vm.prank(k);
        vault.deposit{value: amt}();
        assert(vault.balance(k) == pre + amt);
      }
}
</code></pre>
<p>The <code>setUp</code> function is called before each test case, and can be used to
set up the environment. In this case, we create a new vault, and deposit 7
ether into it for address 42: the <code>vm.deal</code> function sets the balance of the
user to 7 ether, and the <code>vm.prank</code> function sets the caller to address 42. This
should now pass our test:</p>
<pre><code class="language-plain">$ hevm test
Checking 1 function(s) in contract src/setup-test.sol:MySetupTest
[RUNNING] prove_correct(uint8)
   [PASS] prove_correct
</code></pre>
<p>In general, the test should check the postconditions, e.g. the state of the
contract after the call(s) are complete. It should also check that
<a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)">invariants</a> of the
contract, such as total number of tokens, are not violated. You can read more
about testing and cheat codes in the (Foundry
Book)[https://book.getfoundry.sh/forge/cheatcodes] and you can see the
hevm-supported cheat codes <a href="#supported-cheat-codes">below</a>.</p>
<h2 id="understanding-counterexamples"><a class="header" href="#understanding-counterexamples">Understanding Counterexamples</a></h2>
<p>When hevm discovers a failure, it prints an example call how to trigger the
failure. Let's write the following simple solidity code to
<code>src/contract-fail.sol</code>:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";
contract MyContract is Test {
  mapping (address =&gt; uint) balances;
  function prove_single_fail(address recv, uint amt) public {
    require(balances[recv] &lt; 100);
    if (balances[recv] + amt &gt; 100) { revert(); }
    balances[recv] += amt;
    assert(balances[recv] &lt; 100);
  }
}
</code></pre>
<p>When compiling our foundry project, we must either always pass the <code>--ast</code> flag
to <code>forge build</code>, or, much better, set the <code>ast = true</code> flag in the
<code>foundry.toml</code> file:</p>
<pre><code class="language-toml">ast = true
</code></pre>
<p>In case neither <code>--ast</code> was passed, nor <code>ast = true</code> was set in the
<code>foundry.toml</code> file, when running hevm, we will get an error such as:</p>
<pre><code class="language-plain">Error: unable to parse Foundry project JSON: [...]/out/Base.sol/CommonBase.json Contract: "CommonBase"
</code></pre>
<p>In these cases, issue <code>forge clean</code> and run <code>forge build --ast</code> again.</p>
<p>Once the project has been correctly built, we can run <code>hevm test</code>, and get:</p>
<pre><code class="language-plain">$ hevm test
Checking 1 function(s) in contract src/contract-fail.sol:MyContract
[RUNNING] prove_single_fail(address,uint256)
   [FAIL] prove_single_fail(address,uint256)
   Counterexample:
     result:   Revert: 0x4e487b710000000000000000000000000000000000000000000000000000000000000001
     calldata: prove_single_fail(0x0000000000000000000000000000000000000000,100)
</code></pre>
<p>Here, hevm provided us with a calldata, where the receiver happens to be the
zero address, and the value sent is exactly 100. This indeed is the boundary
condition where the function call fails. The function should have had a <code>&gt;=</code>
rather than a <code>&gt;</code> in the <code>if</code>. Notice that in this case, while hevm filled in
the <code>address</code> to give a complete call, the address itself is irrelevant,
although this is not explicitly mentioned.</p>
<h2 id="starting-state-is-always-concrete"><a class="header" href="#starting-state-is-always-concrete">Starting State is Always Concrete</a></h2>
<p>In <code>test</code> mode, hevm runs with the starting state set to concrete values, as
dictated by the <code>setUp()</code> function explained above. This
means that with the solidity-generated default constructor of contracts, state
variables will be zero (unless set otherwise by <code>setUp()</code>),
and arrays and mappings will be empty. If you need a
different starting state, such as e.g. tokens already distributed to some
addresses, you can set that up in the <code>setUp()</code> phase of your test.</p>
<p>In case you need a symbolic starting state, see the <a href="#symbolic-execution-tutorial">Symbolic execution
tutorial</a>. Note that if all you need is a
symbolic calldata, then you don't need to run <code>hevm</code> in symbolic mode, you can
simply run <code>hevm test</code> and hevm will provide you with a symbolic calldata.</p>
<h2 id="test-cases-that-must-always-revert"><a class="header" href="#test-cases-that-must-always-revert">Test Cases that Must Always Revert</a></h2>
<p>Hevm assumes that a test case should not always revert. If you have such a test
case, hevm will warn you and return a FAIL. For example this toy contract:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";
contract MyContract is Test {
  uint256 cntr;
  function prove_allrevert(uint256 val) public {
      if(val &lt; 0) {
          unchecked { cntr = val; }
          revert();
      } else revert();
  }
}
</code></pre>
<p>When compiled with forge and then ran under hevm with <code>hevm test</code>, hevm returns:</p>
<pre><code class="language-plain">Checking 1 function(s) in contract src/contract-allrevert.sol:MyContract
[RUNNING] prove_allrevert(uint256)
   [FAIL] prove_allrevert(uint256)
   Reason:
     No reachable assertion violations, but all branches reverted
     Prefix this testname with `proveFail` if this is expected
</code></pre>
<p>This is sometimes undesirable. In these cases, prefix your contract with
<code>proveFail_</code> instead of <code>prove_</code>:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";
contract MyContract is Test {
  uint256 cntr;
  function proveFail_allrevert_expected(uint256 val) public {
      if(val &lt; 0) {
          unchecked {
            cntr = val;
            cntr += 1;
          }
          revert();
      }
      else revert();
  }
}
</code></pre>
<p>When this is compiled with forge and then checked with hevm, it leads to:</p>
<pre><code class="language-plain">Checking 1 function(s) in contract src/contract-allrevert-expected.sol:MyContract
[RUNNING] proveFail_allrevert_expected(uint256)
   [PASS] proveFail_allrevert_expected(uint256)
</code></pre>
<p>Which is now the expected outcome.</p>
<h2 id="panic-codes"><a class="header" href="#panic-codes">Panic Codes</a></h2>
<p>Solidity generates <a href="https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require">different panic
codes</a>
for different kinds of issues. The list of panic codes returned by Solidity
are:</p>
<ul>
<li>0x00: Used for generic compiler inserted panics, such as e.g. wrong ABI
encoding, or if the ABI decoder fails to decode a value.</li>
<li>0x01: If you call assert with an argument that evaluates to false.</li>
<li>0x11: If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.</li>
<li>0x12; If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).</li>
<li>0x21: If you convert a value that is too big or negative into an enum type.</li>
<li>0x22: If you access a storage byte array that is incorrectly encoded.</li>
<li>0x31: If you call .pop() on an empty array.</li>
<li>0x32: If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i &gt;= x.length or i &lt; 0).</li>
<li>0x41: If you allocate too much memory or create an array that is too large.</li>
<li>0x51: If you call a zero-initialized variable of internal function type.</li>
</ul>
<p>Of these, <code>hevm test</code> will only report counterexamples for 0x1, or for custom errors that
developers define, such as:</p>
<pre><code class="language-solidity">error InsufficientBalance(uint256 requested, uint256 available);
....
uint reqested = ...;
uint available = ...;
if (requested &gt; available) {
    revert InsufficientBalance(requested, available);
}
</code></pre>
<p>Notice that for panic codes, the returned counterexample will produce
a return whose first 4 bytes will be:</p>
<pre><code class="language-plain">$ cast keccak "Panic(uint256)" | cut -c 1-10
0x4e487b71
</code></pre>
<p>And if it's a custom error, the first 4 bytes will be:</p>
<pre><code class="language-plain">$ cast keccak "Error(string)" | cut -c 1-10
0x08c379a0
</code></pre>
<h2 id="supported-cheat-codes"><a class="header" href="#supported-cheat-codes">Supported Cheat Codes</a></h2>
<p>Since hevm is an EVM implementation mainly dedicated to testing and
exploration, it features a set of "cheat codes" which can manipulate the
environment in which the execution is run. These can be accessed by calling
into a contract (typically called <code>Vm</code>) at address
<code>0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</code>, which happens to be keccak("hevm cheat code"),
implementing the following methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>function prank(address sender) public</code></td><td>Sets <code>msg.sender</code> to the specified <code>sender</code> for the next call.</td></tr>
<tr><td><code>function startPrank(address sender) public</code></td><td>Sets <code>msg.sender</code> to the specified <code>sender</code> until <code>stopPrank()</code> is called.</td></tr>
<tr><td><code>function stopPrank() public</code></td><td>Resets <code>msg.sender</code> to the default sender.</td></tr>
<tr><td><code>function deal(address usr, uint amt) public</code></td><td>Sets the eth balance of <code>usr</code> to <code>amt</code>. Note that if <code>usr</code> is a symbolic address, then it must be the address of a contract that has already been deployed. This restriction is in place to ensure soundness of our symbolic address encoding with respect to potential aliasing of symbolic addresses.</td></tr>
<tr><td><code>function store(address c, bytes32 loc, bytes32 val) public</code></td><td>Sets the slot <code>loc</code> of contract <code>c</code> to <code>val</code>.</td></tr>
<tr><td><code>function warp(uint x) public</code></td><td>Sets the block timestamp to <code>x</code>.</td></tr>
<tr><td><code>function roll(uint x) public</code></td><td>Sets the block number to <code>x</code>.</td></tr>
<tr><td><code>function assume(bool b) public</code></td><td>Add the condition <code>b</code> to the assumption base for the current branch. This functions almost identically to <code>require</code>. For most users, <code>require</code> is preferable. However, in case you wish to understand &amp; modify the internal IR of hevm, you may want to use <code>assume</code>.</td></tr>
<tr><td><code>function load(address c, bytes32 loc) public returns (bytes32 val)</code></td><td>Reads the slot <code>loc</code> of contract <code>c</code>.</td></tr>
<tr><td><code>function sign(uint sk, bytes32 digest) public returns (uint8 v, bytes32 r, bytes32 s)</code></td><td>Signs the <code>digest</code> using the private key <code>sk</code>. Note that signatures produced via <code>hevm.sign</code> will leak the private key.</td></tr>
<tr><td><code>function addr(uint sk) public returns (address addr)</code></td><td>Derives an ethereum address from the private key <code>sk</code>. Note that <code>hevm.addr(0)</code> will fail with <code>BadCheatCode</code> as <code>0</code> is an invalid ECDSA private key.</td></tr>
<tr><td><code>function ffi(string[] calldata) external returns (bytes memory)</code></td><td>Executes the arguments as a command in the system shell and returns stdout. Expects abi encoded values to be returned from the shell or an error will be thrown. Note that this cheatcode means test authors can execute arbitrary code on user machines as part of a call to <code>dapp test</code>, for this reason all calls to <code>ffi</code> will fail unless the <code>--ffi</code> flag is passed.</td></tr>
<tr><td><code>function createFork(string calldata urlOrAlias) external returns (uint256)</code></td><td>Creates a new fork with the given endpoint and the <em>latest</em> block and returns the identifier of the fork.</td></tr>
<tr><td><code>function selectFork(uint256 forkId) external</code></td><td>Takes a fork identifier created by <code>createFork</code> and sets the corresponding forked state as active.</td></tr>
<tr><td><code>function activeFork() external returns (uint256)</code></td><td>Returns the identifier of the current fork.</td></tr>
<tr><td><code>function label(address addr, string calldata label) external</code></td><td>Labels the address in traces</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="completeness-and-false-positives.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="equivalence-checking-tutorial.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="completeness-and-false-positives.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="equivalence-checking-tutorial.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="solidity.min.js"></script>
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>



    </div>
    </body>
</html>
